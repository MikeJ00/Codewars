//--1--//Какие способы создания объекта есть в JS

// 1.1 Литерал объекта - состоит из пары ключ - значение
let object = {
    name: "Ivan",
    age: 39
}
//1.2 Констурктор объекта
let object1 = new Object();
let object2 = Object();

// 1.3 Метод создания объекта - полезен для создания новых объектов
// на основе существвующих
let obj1 = Object.create(null);
let vehicle = {
    wheels: '4',
    fuelType: 'Gasoline',
    color: 'Green'
}
let carProps = {
    type: {
        value: 'Volkswagen'
    },
    model: {
        value: 'Golf'
    }
}
let car = Object.create(vehicle, carProps);
console.log(car);

// 1.4 Функция конструктор - При таком подходе создаем любую функцию и
// применяем оператор new для создания экземпляров объекта.
function Person(name, age) {
    this.name = name;
    this.age = age
}

let obj2 = new Person("Kolja", 90)
console.log(obj2)

// 1.5 Функция конструктор с прототипом
function Person1(name) {
}

Person1.prototype.name = "Ivan";
let obj3 = new Person1();
console.log(obj3)

// 1.6 Метод присоединения объекта - используется для копирования всех свойств из одного
// или нескольких исходных объектов и сохранения их в целевом объекте.
const orgObj = {company: "RogaAndCop"}
const carObj = {name: "UAZ"}
const targetObj = Object.assign({}, orgObj, carObj)
console.log(targetObj)

// 1.7 ES6 Классовый синтакс
class Person2 {
    constructor(name) {
        this.name = name;
    }
}

let obj4 = new Person2("IIII")
console.log(obj4)

// 1.8 Паттерн синглтон - это объект, экземпляр которого может быть создан только один раз
// Повторные вызовы будут возвращать один и тот же экземпляр.
let obj5 = new (function () {
    this.name = "Only 1 name"
})();
console.log(obj5)

//--2--// Что такое цепочка прототипов
// Цепочка прототипов используется для создания новых типов объектов на основе существующих.
//Это что-то типа наследование в классах.

//--3--// Разница между Call/Apply/bind
// 3.1 Call вызывает  функцию с заданными значением и аргументами, следующими друг за другом
let empl1 = {firstName: "Gena", lastName: "Plot"}
let empl2 = {firstName: "Ok", lastName: "Wsr"}

function invite(greeting1) {
    console.log(greeting1 + " " + this.firstName + " " + this.lastName)
}

invite.call(empl1, "Hey!")
invite.call(empl2, "Good Morning!")

// 3.2 Apply вызывает  функцию с заданными значением и позволяет передать аргумент в виде массива
let empl3 = {firstName: "Gena", lastName: "Plot"}
let empl4 = {firstName: "Ok", lastName: "Wsr"}

function invite1(greeting1) {
    console.log(greeting1 + " " + this.firstName + " " + this.lastName)
}

invite1.apply(empl3, ["Hello!"])
invite1.apply(empl4, ["WWWW!"])

// 3.3 Bind возвращает новую функцию, позволяющую передавать любое количество аргументов.
let empl5 = {firstName: "Gena", lastName: "Plot"}
let empl6 = {firstName: "Ok", lastName: "Wsr"}

function invite2(greeting1) {
    console.log(greeting1 + " " + this.firstName + " " + this.lastName)
}

let inviteEmpl1 = invite2.bind(empl5)
let inviteEmpl2 = invite2.bind(empl6)
inviteEmpl1("QQQQQQQQQ")
inviteEmpl2("SSSSSSSSSSSSS")
// Call and Apply are pretty much interchangeable.
// Both execute the current function immediately.
// You need to decide whether it’s easier to send in an array or a comma
// separated list of arguments. You can remember by treating
// Call is for comma (separated list) and Apply is for Array.
// Bind creates a new function that will have this set to the first parameter passed to bind().
//     РУССКИЙ
// Позвонить и подать заявку практически взаимозаменяемы.
// Оба немедленно выполняют текущую функцию.
// Вам нужно решить, что проще отправить: массив или список аргументов, разделенных запятыми.
// Вы можете запомнить это, обработав Call для запятой (разделенный список),
// а Apply для массива. Bind создает новую функцию, для которой это значение будет установлено
// в качестве первого параметра, переданного в функцию Bind().

//--4--// Что такое JSON и его операции
// JSON - это текстовый формат данных, который соотв синтаксу объектов JS.
// Используем когда нам нужно передать данные по сети
// 4.1 Parsing - преобразование строки в объект
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);
console.log(obj.count);
// 4.2 Stringification - преобразование объекта в строку для передачи по сети
console.log(JSON.stringify({x: 5, y: 6}));
console.log(JSON.stringify(new Date()));

//--5--// Какова цель метода slice массива
// возвращает выбранные элементы массива как новый объект массива.
// Он выбирает элементы, начинающиеся с данного начального аргумента, и заканчиваются данным
// необязательным конечным аргументом, не включая последний элемент.
//Если вы опустите второй аргумент, он будет выбирать до конца массива.
let arrayIntegers = [1, 2, 3, 4, 5];
let arrayIntegers1 = arrayIntegers.slice(0, 2);
let arrayIntegers2 = arrayIntegers.slice(1);
console.log(arrayIntegers1, arrayIntegers2)
console.log(arrayIntegers)

//--6--// Какова цель метода splice массива
// Метод splice() добавляет/удаляет элементы в массив или из него, а затем возвращает удаленный элемент.
// Первый аргумент указывает позицию/индекс массива для вставки или удаления, тогда как необязательный второй аргумент
// указывает количество элементов, которые необходимо удалить.
//     Каждый дополнительный аргумент добавляется в массив.
let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
let arrInt1 = arrayIntegersOriginal1.splice(0, 2)
let arrInt2 = arrayIntegersOriginal2.splice(3)
console.log(arrInt1, arrInt2)
console.log(arrayIntegersOriginal1, arrayIntegersOriginal2)

//--7--// В чем разница между splice/slice
// Slice                                         Splice
// Не изменяет исходный массив (неизменяемый)    Изменяет исходный массив (изменяемый)
// Возвращает подмножество исходного массива     Возвращает удаленные элементы в виде массива
// Используется для выбора элементов из массива  Используется для вставки/удаления элементов в/из массива.

//--8--// Сравнение map & Object
// Объекты похожи на Карты в том, что оба позволяют устанавливать ключи в значения, извлекать эти значения, удалять ключи
// и определять, хранится ли что-то по ключу. По этой причине объекты исторически использовались в качестве карт.
// Но есть важные различия, которые делают использование карты предпочтительнее в определенных случаях:
// 8.1 Ключами объекта могут быть строки и символы,
//тогда как для map они могут быть любым значением, включая функции, объекты и любые примитивы.
// 8.2 Ключи на map упорядочены, а ключи, добавленные в объект, — нет.
// Таким образом, при переборе объект Map возвращает ключи в порядке вставки.
// 8.3 Ключи на map упорядочены, а ключи, добавленные в объект, — нет.
// Таким образом, при переборе объект Map возвращает ключи в порядке вставки.
// 8.4 map является итерируемой, и поэтому ее можно перебирать напрямую,
// тогда как итерация по объекту требует каким-то образом получить его ключи и перебрать их.
// 8.5 У объекта есть прототип, поэтому в объекте есть ключи по умолчанию,
// которые могут столкнуться с вашими ключами, если вы не будете осторожны.
// Начиная с ES5, это можно обойти, создав объект (который можно назвать картой) с помощью Object.create(null),
// но такая практика применяется редко.
// 8.6 Map может работать лучше в сценариях, связанных с частым добавлением и удалением пар ключей.

//--9--// В чем разница между операторами == и ===
// JavaScript обеспечивает как строгое (===, !==), так и преобразование типов (==, !=) сравнение на равенство.
//Строгие операторы учитывают тип переменной, тогда как нестрогие операторы выполняют
// коррекцию/преобразование типа на основе значений переменных.
//Строгие операторы следуют приведенным ниже условиям для разных типов:
//Две строки строго равны, если они имеют одинаковую последовательность символов,
//одинаковую длину и одинаковые символы в соответствующих позициях.
//Два числа строго равны, если они численно равны, т. е. имеют одинаковое числовое значение.
//Здесь есть два особых случая:
// NaN не равен ничему, включая NaN.
//Положительные и отрицательные нули равны друг другу.
// Два логических операнда строго равны, если оба истинны или оба ложны.
// Два объекта строго равны, если они ссылаются на один и тот же объект.
// Типы Null и Undefine не равны ===, но равны == . т.е. null===undefined --> ложь,
//     но null==undefined --> true
console.log(199, 0 == false)
console.log(200, 0 === false)
console.log(201, 1 == "1")
console.log(202, 1 === "1")
console.log(null == undefined)
console.log(null === undefined)
console.log(NaN === NaN)
console.log(NaN === NaN)
console.log({} === {})
console.log({} == {})

//--10--// Что такое лямбда-выражения или стрелочные функции?
// Стрелочная функция представляет собой более короткий/лаконичный синтаксис функционального выражения
// и не имеет собственных аргументов this, super или new.target.
// Эти функции лучше всего подходят для функций, не являющихся методами, и их нельзя использовать
// в качестве конструкторов.
const arrowFunc1 = (a, b) => a * b;
console.log(arrowFunc1(2, 5))

//--11--// Что такое функция первого класса?
// В Javascript функции являются объектами первого класса. Функции первого класса означают,
//что функции на этом языке рассматриваются как любая другая переменная.
//Например, в таком языке функция может передаваться в качестве аргумента другим функциям,
//может быть возвращена другой функцией и может быть присвоена как значение переменной.
//Например, в приведенном ниже примере функции-обработчики, назначенные прослушивателю
// const handler = () => console.log("This is a click handler function");
// document.addEventListener("click", handler);

//--12--// Что такое функция первого порядка?
// Функция первого порядка — это функция, которая не принимает другую функцию в качестве аргумента
// и не возвращает функцию в качестве возвращаемого значения.
const firstOrder = () => console.log("I am a first order function!");
firstOrder()

//--13--// Что такое функция высшего порядка?
// Функция высшего порядка — это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию
// в качестве возвращаемого значения, или и то, и другое.
//     Синтаксическая структура функции высшего порядка будет следующей:
const firstOrderFunc = () => console.log("Hello, I'm a higher order function")
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc)
// Вы также можете вызвать функцию, которую вы передаете функции более высокого порядка,
//     в качестве функции обратного вызова. Функция высшего порядка полезна для написания модульного и
// многократно используемого кода.

//--14--// Что такое унарная функция?
// Унарная функция (т.е. монадическая) — это функция, которая принимает ровно один аргумент.
//     Он обозначает один аргумент, принимаемый функцией. Возьмем пример унарной функции:
const unaryFunc = (a) => console.log(a + 10)
unaryFunc(30)

//--15--// Что такое функция каррирования?
// Каррирование — это процесс преобразования функции с несколькими аргументами в последовательность функций,
//каждая из которых имеет только один аргумент.
//Применяя каррирование, n-арная функция превращается в унарную функцию.
const multiArgFunction = (a, b, c) => a + b + c;
console.log(multiArgFunction(1, 2, 3));
const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
console.log(curryUnaryFunction(1)(2)(8))
// Каррированные функции отлично подходят для улучшения повторного использования кода и функциональной композиции.

//--16--//Что такое чистая функция
// ЧФ - это функция, возвращаемое значение которой определяется только ее
// аргументами без каких-либо побочных эффектов. то есть,Если вы вызываете функцию с одинаковыми
// аргументами «n» количество раз и «n» количество мест в
// приложении, она всегда будет возвращать одно и то же значение.
let numberArr = [];
const impureAddNumber = (number) => numberArr.push(number)
const pureAddNumber = (number) => (argNumberArray) => argNumberArray.concat([number])

console.log(impureAddNumber(6))
console.log(numberArr)
console.log(pureAddNumber(9)(numberArr))

// Согласно приведенным выше фрагментам кода, функция Push сама по себе является нечистой, изменяя массив и
// возвращая индекс номера push, независимый от значения параметра, тогда как Concat, с другой стороны, берет массив и
// объединяет его с другим массивом, создавая совершенно новый массив. без побочных эффектов. Кроме того, возвращаемое
// значение представляет собой объединение предыдущего массива.
// Помните, что чистые функции важны, поскольку они упрощают модульное тестирование без каких-либо побочных
// эффектов и отсутствия необходимости внедрения зависимостей.
//Они также избегают жесткой связи и затрудняют выход из строя вашего приложения, не вызывая каких-либо побочныхэффектов.
//Эти принципы сочетаются с концепцией неизменяемости ES6: предпочтение отдается использованию const, а не let.

//--17--//Какова цель ключевого слова let
//Оператор let объявляет локальную переменную области действия блока.
//Следовательно, переменные, определенные с помощью ключевого слова let,
// ограничены по объему блоком, оператором или выражением, в котором они используются.
//В то время как переменные, объявленные с помощью ключевого слова var, используются для определения переменной
// глобально или локально для всей функции независимо от области действия блока.
let counter = 37;
if (counter === 30) {
    let counter = 31;
    console.log(counter); // 31
}
console.log(counter);

//--18--//В чем разница между let и var
// var                                                               let
// Он был доступен с самого начала JavaScript.                       Представлен как часть ES6
// Он имеет функциональную область видимости                         Он имеет область видимости блока
// Объявление переменной будет поднято                               Поднят, но не инициализирован
// Можно повторно объявить переменную в той же области видимости.    Невозможно повторно объявить переменную
let pol1;
console.log(pol1)
pol = "WWW"
console.log(pol)
var pol = 2;
console.log(pol)
function userDetails(username){
    if(username){
        let age = 30;
        console.log(salary)// undefined due to hoisting
        console.log(age)// Cannot access 'age' before initialization
        // let age = 30;
        var salary = 10000;
    }
    // console.log(age)//age is not defined
    console.log(salary)
}
userDetails("OL")

//--19--//
//--20--//Как переобъявить переменные в блоке switch без ошибки?
// Если вы попытаетесь переопределить переменные в блоке переключателя, это приведет к ошибкам,
//     поскольку существует только один блок.
//     Например, приведенный ниже блок кода выдает синтаксическую ошибку, как показано ниже:
let counter1 = 1;
let x = 5
switch (x) {
    case 0:
        let name;
        break;

    case 1:
        // let name; // SyntaxError for redeclaration.
        break;
}
// Чтобы избежать этой ошибки, мы моежм создать вложенный блок внутри
// предложения case и создать новую лексическую среду с областью действия блока.
let counter2 = 1;
switch (x) {
    case 0: {
        let name;
        break;
    }
    case 1: {
        let name; // No SyntaxError for redeclaration.
        break;
    }
}

//--21--//Что такое временная мертвая зона
// Временная мертвая зона (TDZ) — это определенный период или область блока, где переменная недоступна
// до тех пор, пока она не будет инициализирована значением. Такое поведение в JavaScript,
//     которое происходит при объявлении переменной с ключевыми словами let и const, но не с помощью var.
// В ECMAScript 6 доступ к переменной let или const до ее объявления (в пределах ее области действия)
// вызывает ошибку ReferenceError.
function somemethod(){
    console.log(ex1);//undefined
    // console.log(ex2);//Cannot access 'ex2' before initialization
    var ex1 = 5;
    let ex2 = 10;
}
somemethod()

//--22--//Что такое IIFE (выражение функции с немедленным вызовом)
// IIFE (выражение немедленно вызываемой функции) — это функция JavaScript, которая
// запускается сразу после ее определения.Подпись будет такой, как показано ниже:
//     function (){
//         console.log("55")
// }();
// Основная причина использования IIFE — обеспечение конфиденциальности данных,
//     поскольку любые переменные, объявленные в IIFE, не могут быть доступны внешнему миру.
//     т. е. если вы попытаетесь получить доступ к переменным из IIFE, то выдается ошибка, как показано ниже:
let a1 = (function () {
    var message = "IIFE";
    console.log(message);
})();
// console.log(message);//message is not defined

//--23--// Как декодировать или кодировать URL-адрес в JavaScript?
// Функция encodeURI() используется для кодирования URL-адреса.
//     Эта функция требует строку URL-адреса в качестве параметра и возвращает эту закодированную строку.
//     Функция decodeURI() используется для декодирования URL-адреса. Эта функция требует
// в качестве параметра закодированную строку URL-адреса и возвращает эту декодированную строку.
//     Примечание. Если вы хотите закодировать такие символы, как / ? : @ & = + $ #
// тогда вам нужно использовать encodeURIComponent().
let uri = "employeeDetails?name=john&occupation=manager";
let encoded_uri = encodeURI(uri);
let decoded_uri = decodeURI(encoded_uri);
console.log(encoded_uri)
console.log(decoded_uri)

//--24--//Что такое мемоизация
// Мемоизация — это метод функционального программирования, который пытается повысить
// производительность функции за счет кэширования ранее вычисленных результатов.Каждый раз,
//     когда вызывается мемоизированная функция, ее параметры используются для индексации кеша.
//     Если данные присутствуют, то их можно вернуть, не выполняя всю функцию.
//     В противном случае функция выполняется, а затем результат добавляется в кеш.
//     Давайте рассмотрим пример добавления функции с мемоизацией:
const memoizAddition = () => {
    let cache = {};
    return (value) => {
        if (value in cache) {
            console.log("Fetching from cache");
            return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
        } else {
            console.log("Calculating result");
            let result = value + 20;
            cache[value] = result;
            return result;
        }
    };
};
// returned function from memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //output: 40 calculated
console.log(addition(30)); //output: 40 calculated
console.log(addition(40)); //output: 40 calculated
console.log(addition(20)); //output: 40 cached

//--25--//Что такое подъем(hoisting)
// https://www.w3schools.com/js/js_hoisting.asp#:~:text=Hoisting%20is%20JavaScript's%20default%20behavior%20of%20moving%20all%20declarations%20to,script%20or%20the%20current%20function).
// Подъем — это механизм JavaScript, в котором переменные, объявления функций и классы
// перемещаются в верхнюю часть области видимости перед выполнением кода.
//Помните, что JavaScript поддерживает только объявления, а не инициализацию.
p = 0
console.log(p)
var p;
var message1;
console.log(message); //output : undefined
console.log(message1); //output : undefined
message1 = "variable hoisted"
var message = "The variable Has been hoisted";
console.log(message)
var xx = 5;
var yyy;
// console.log( xx + " " +  yy + " " + yyy)
// console.log( xx + yyy)
// console.log(xx)
// console.log(yy)
var yy = 7
yyy = 9
message2("wwwww")
function message2(name) {
    console.log(name);
}

//--26--//Что такое классы в ES6
// В ES6 классы Javascript представляют собой в первую очередь синтаксический сахар по сравнению с
// существующим в JavaScript наследованием на основе прототипов.
//     Например, наследование на основе прототипа, записанное в функциональном выражении, как показано ниже:
function Bike(model, color) {
    this.model = model;
    this.color = color;
}

Bike.prototype.getDetails = function () {
    return this.model + " bike has" + this.color + " color";
};
let Bike2 = new Bike("toyota","white");
console.log(Bike2.getDetails())
// Классы ES6 могут быть определены как альтернатива
class Bike1 {
    constructor(color, model) {
        this.color = color;
        this.model = model;
    }
    getDetails() {
        return this.model + " bike has " + this.color + " color";
    }
}
let myBike = new Bike1("black", "bmw");
console.log(myBike.getDetails())
//--27--//Что такое замыкания
// Замыкание — это комбинация функции, связанной (заключенной) вместе с ее лексическим окружением,
//     в котором эта функция была объявлена. то есть это внутренняя функция, которая имеет доступ к
// переменным, функциям и другим данным внешней или охватывающей функции даже после того, как внешняя
// функция завершила свое выполнение.
//     Замыкание имеет три цепи охвата.
// Собственная область действия, где переменные определены между фигурными скобками.
//     Переменные внешней функции
// Глобальные переменные
function Welcome(name) {
    var greetingInfo = function (message) {
        console.log(message + " " + name);
    };
    return greetingInfo;
}
var myFunction = Welcome("John");
myFunction("Welcome "); //Output: Welcome John
myFunction("Hello Mr."); //output: Hello Mr. John
// Согласно приведенному выше коду, внутренняя функция (т. е. GreetingInfo)
// имеет доступ к переменным в области внешней функции
// (т. е. Welcome) даже после возврата внешней функции.
// +еще пример
function makeAdder(x){
    return function(y){
        return x + y
    }
}
let add6 = makeAdder(6)
console.log(add6(2))
// Одна из основных причин, по которой замыкания полезны, это то, что они позволяют "скрывать"
// значения внутри функции, защищая их от внешнего мира. Это может быть полезно, когда вы хотите
// сохранить состояние, которое должно быть доступно только для определенной функции.
//     Они также могут быть использованы для создания функций, которые имеют "приватные" переменные.
//     В JavaScript нет встроенной возможности сделать переменные приватными,
//     но это можно эмулировать с помощью замыкания.

//--28--//Что такое модули
// Модуль – это просто файл. Один скрипт – это один модуль.
// Модули относятся к небольшим единицам независимого, многократно используемого кода, а также служат
// основой многих шаблонов проектирования JavaScript.
//     Большинство модулей JavaScript экспортируют литерал объекта, функцию или конструктор.

//--29--//Почему нужно использовать модули
// 29.1 Повышение читаемости кода
// Модули помогают организовать код, делая его более понятным и удобным для чтения.
// 29.2 Повторное использование кода
// Код в модуле можно легко использовать в других частях вашего приложения или даже в других проектах.
// 29.3 Изоляция кода:
// Каждый модуль имеет свою собственную область видимости, что означает,
//     что переменные, объявленные в модуле, не видны вне модуля.

//--30--//Что такое область видимости в JavaScript
// Область видимости — это доступность переменных, функций и объектов в определенной части вашего кода
// во время выполнения.
// Глобальная область видимости: Переменные, объявленные вне любой функции,
// находятся в глобальной области видимости и доступны из любой части кода.
//Локальная область видимости: Переменные, объявленные внутри функции,
// находятся в локальной области видимости и доступны только внутри этой функции.
let globalP = "I'm a global"
function examplFunciton() {
    let localP = "I'm a local"
    console.log(533,localP)
    console.log(534,globalP)
}
examplFunciton();
console.log(537,globalP);
// console.log(538,localP);//localP is not defined

//--31?--//Что такое service worker
// service worker — это, по сути, сценарий (файл JavaScript), который выполняется в фоновом режиме
// отдельно от веб-страницы и предоставляет функции, не требующие веб-страницы или взаимодействия с пользователем.
// Некоторые из основных функций сервисных работников — это богатый автономный опыт
// (сначала разработка веб-приложений в автономном режиме),
// периодическая фоновая синхронизация, push-уведомления, перехват и обработка сетевых запросов,
// а также программное управление кешем ответов.

//--32?--//Как манипулировать DOM с помощью сервис-воркера
// Cервис-воркер не может получить прямой доступ к DOM.
// Но он может взаимодействовать со страницами, которые он контролирует,
// отвечая на сообщения, отправленные через интерфейс postMessage, и эти страницы могут манипулировать DOM.

//--33?--//Как повторно использовать информацию при перезапуске Service Worker?
// Проблема с сервис-воркером заключается в том, что он завершается, когда он не используется,
// и перезапускается, когда он в следующий раз понадобится, поэтому вы не можете полагаться на
// глобальное состояние в обработчиках onfetch и onmessage сервис-воркера.
// В этом случае сервисные работники будут иметь доступ к API IndexedDB для его сохранения и
// повторного использования при перезапусках.

//--34--//Что такое IndexedDB?
// IndexedDB — это низкоуровневый API для хранения на стороне клиента больших объемов структурированных данных,
// включая файлы и BLOB-объекты.
// Этот API использует индексы для обеспечения высокопроизводительного поиска этих данных.

//--35--//Что такое веб-хранилище?
// Веб-хранилище — это API, который предоставляет механизм, с помощью которого браузеры
// могут хранить пары ключ/значение локально в браузере пользователя, гораздо более интуитивно
// понятным способом, чем использование файлов cookie.
// Веб-хранилище предоставляет два механизма хранения данных на клиенте.
// Local storage: оно хранит данные текущего происхождения без срока действия.
// Session storage: оно хранит данные за один сеанс, и данные теряются при закрытии вкладки браузера.

//--36?--//Что такое почтовое сообщение?(post message)
// это метод, который обеспечивает связь между источниками между объектами Window
// (т. е. между страницей и всплывающим окном, которое она создала,
// или между страницей и встроенным в нее iframe).
// Как правило, сценариям на разных страницах разрешен доступ друг к другу тогда и только тогда,
// когда страницы следуют политике одного и того же происхождения
// (т. е. страницы используют один и тот же протокол, номер порта и хост).

//--37--//Что такое файл cookie
// Файл cookie — это часть данных, которая хранится на вашем компьютере и доступна вашему браузеру.
// Файлы cookie сохраняются в виде пар ключ/значение.
// Например, можно создать файл cookie с именем пользователя, как показано ниже:
// document.cookie = "username=John";
// WebBrowser------------Request---------> Server
// -----//---<-------Response+Cookie----------//--
// -----//----------Request+Cookie-------->---//--

//--38--//Для чего нужны куки
// Файлы cookie используются для запоминания информации о профиле пользователя (например, имени пользователя).
// В основном это включает в себя два шага,
// |.Когда пользователь посещает веб-страницу, профиль пользователя может быть сохранен в файле cookie.
// ||.Когда пользователь в следующий раз посетит страницу, файл cookie  помнит профиль пользователя.

//--39--//Какие параметры есть в файле cookie
// Для файлов cookie доступно несколько вариантов
//|.По умолчанию файл cookie удаляется при закрытии браузера, но вы можете изменить это поведение,
// установив дату истечения срока действия (по времени UTC).
// document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
//||.По умолчанию файл cookie принадлежит текущей странице.
// Но вы можете сообщить браузеру, какому пути принадлежит файл cookie, используя параметр пути.
// document.cookie = "username=John; path=/services";

//--40--//Как удалить файл cookie
// Можно удалить файл cookie, установив дату истечения срока его действия как прошедшую дату.
// В этом случае не нужно указывать значение cookie.
// Например, можно удалить файл cookie имени пользователя на текущей странице, как показано ниже.
//     document.cookie =
//     "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
// Следует определить параметр пути к файлам cookie, чтобы гарантировать удаление нужного
// файла cookie. Некоторые браузеры не позволяют удалять файлы cookie, если вы не укажете параметр пути.

//--41--//В чем разница между файлами cookie, локальным хранилищем и хранилищем сеансов?
// Cookie	                                        |Local storage	       |Session storage         |
// Как на стороне сервера, так и на стороне клиента |         только сторона клиента                |
// Продолжительность: Как настроено с использованием|пока не будет удален  |При закрытии владки     |
// параметра Expires                                |                      |                        |
// SSL: Поддерживается                              |          не поддерживается и там и там        |
// Макс.размер данных - 4кб                         |               5 МБ и там и там                |
// __________________________________________________________________________________________________

//--42--//В чем основная разница между localStorage и sessionStorage?
// LocalStorage аналогичен SessionStorage, но он сохраняет данные, даже когда браузер закрывается
// и снова открывается (т. е. у него нет срока действия),тогда как в sessionStorage данные очищаются
// после завершения сеанса страницы.

//--43--//Как получить доступ к веб-хранилищу?
// Объект Window реализует объекты WindowLocalStorage и WindowSessionStorage,
// которые имеют свойства localStorage(window.localStorage) и sessionStorage(window.sessionStorage)
// Эти свойства создают экземпляр объекта Storage, с помощью которого можно устанавливать,
// получать и удалять элементы данных для определенного домена и типа хранилища (сеансовое или локальное).
// Например, можно читать и записывать объекты локального хранилища, как показано ниже.
// localStorage.setItem("logo", document.getElementById("logo").value);
// localStorage.getItem("logo");

//--44--//Какие методы доступны в session storage?
// Хранилище сеансов предоставляет методы для чтения, записи и очистки данных сеанса.
// Сохраняем данные в sessionStorage
// sessionStorage.setItem("ключ", "значение");
// Получаем данные в sessionStorage
// sessionStorage.getItem("key")
// Удаляем данные в sessionStorage
// sessionStorage.removeItem("key")
// Удаляем все сохраненные данные из sessionStorage
// sessionStorage.clear()

//--45--//Что такое storage event и его обработчик событий
// StorageEvent — это событие, которое срабатывает, когда область хранения была изменена в контексте
// другого документа. Тогда как свойство onstorage — это EventHandler для обработки событий хранилища.
// Событие хранения (Storage Event) в JavaScript активируется, когда происходят изменения в
// локальном или сессионном хранилище (LocalStorage или SessionStorage).
// window.onstorage = functionRef;
// window.addEventListener('storage',function (event){
//     console.log("Change storage:", event.key,event.newValue)
// })

//--46--//Зачем нужно веб-хранилище
// Веб-хранилище более безопасно, и большие объемы данных могут храниться локально,
// не влияя на производительность веб-сайта. Кроме того, информация никогда не передается на сервер.
// Это более рекомендуемый подход, чем использование файлов cookie.

//--47--//Как проверить поддержку веб-хранилища браузером
// if(typeof Storage !== undefined){
//
// } else {
//     "Sorry, storage not support"
// }

//--48--//Как проверить поддержку браузера  web workers
// if(typeof Worker !== undefined){
//
// } else{
//     "Sorry don't support"
// }

//--49?--//Пример web workers
// let y = 0;
// function timedCount(){
//     y = y +1;
//     postMessage(y);
//     setTimeout("timedCount()",1000)
// }
// timedCount()
// if(typeof w ==undefined){
//     w = new Worker("theory.js")
// }
// w.onmessage = function (event){
//     document.getElementById("message").innerHTML = event.data
//
// }
// w.terminate()

//--50--//Каковы ограничения web workers в DOM
// web workers  не имеют доступа к объектам JavaScript ниже, поскольку они определены во внешних файлах.
// |.Window object
// ||.Document object
// |||.Parent object


//--51--//Что такое Promise
// Промис — это объект,(- это объект, представляющий конечное завершение или сбой асинхронной операции. )
// который может когда-нибудь в будущем создать одно значение
// либо с разрешенным значением, либо с причиной, по которой оно не было разрешено
// (например, сетевая ошибка).
// Оно будет находиться в одном из трех возможных состояний: выполнено, отклонено или ожидается.
// const promise = new Promise(function(resolve,reject){
//     //
// })
// const promise = new Promise(
//     (resolve) => {
//         console.log(1)
//         setTimeout(() => {
//             resolve("I'm a Promise!");
//         }, 1000);
//     },
//     (reject) => {}
// );
//
// promise.then((value) => console.log(value));

//--52--//Зачем нужны промисы
// Промисы используются для обработки асинхронных операций.
// Они предоставляют альтернативный подход к колбэкам, уменьшая коллбэк хэл и написав более чистый код.
//callbackHell
// getData(function(a){
//     getMoreData(a, function(b){
//         getMoreData(b, function(c){
//             getMoreData(c, function(d){
//                 getMoreData(d, function(e){
//                     // ...
//                 });
//             });
//         });
//     });
// });
// //Analog Promise
// getData()
//     .then(a => getMoreData(a))
//     .then(b => getMoreData(b))
//     .then(c => getMoreData(c))
//     .then(d => getMoreData(d))
//     .then(e => {
//         // ...
//     })
//     .catch(error => {
//         // обработка ошибок
//     });

//--53--//Каковы стадии промисов
// Промис может находиться в одном из следующих состояний:
// Ожидание (Pending): начальное состояние, не выполнено и не отклонено.
// let promise1 = new Promise(function(res,rej){
//     setTimeout(function(){
//         res("Fullfiled")
//     }, 3000)
// });
// console.log(758,promise1)
// Выполнено (Fulfilled): значит операция завершена успешно.
// let promise2 = new Promise(function(res,rej){
//     setTimeout(function(){
//         res("Fullfiled")
//     }, 3000)
// });
// console.log(765,promise2.then(function (res){
//     console.log(res)
// }))
// promise2.then(function (res){
//     console.log(769,res)
// })
// Отклонено (Rejected): значит операция завершена с ошибкой.
let promise3 = new Promise(function(res,rej){
    setTimeout(function(){
        rej("Rejected")
    }, 1000)
});
console.log(765,promise3.catch(function (w){
    console.log(w)
}))

//--54--//Что такое коллбэк функция
// Функция обратного вызова — это функция, передаваемая в другую функцию в качестве аргумента.
// Эта функция вызывается внутри внешней функции для завершения действия.
function callBackFunc(name){
    console.log("Hi " + name)
}
function outerFunc(callBack){
    let name = "Igor"
    callBack(name)
}
outerFunc(callBackFunc)

//--55--//Зачем нужны коллбэк функции
//ЧТобы не останавливать обработку кода(скрипта) при нахождении в коле асинхронных оперции
// JavaScript - это однопоточный язык, что означает, что он может обрабатывать только одну операцию за раз.
// Когда вы выполняете долгую операцию, такую как чтение файла или запрос к серверу,
// вы не хотите блокировать остальной код.
// Коллбэк-функции позволяют вам запустить долгую операцию, а затем продолжить выполнение кода.
// Когда долгая операция завершена, ваша коллбэк-функция вызывается с результатом.
function firstFunction() {
    // Simulate a code delay
    setTimeout(function () {
        console.log("First function called");
    }, 1000);
}
function secondFunction() {
    console.log("Second function called");
}
firstFunction();
secondFunction();

// Second function called
// First function called

//--56--//Что такое  callback hell
// Callback Hell — это антишаблон с несколькими вложенными обратными вызовами,
// который затрудняет чтение и отладку кода при работе с асинхронной логикой.
// async1(function(){
//     async2(function(){
//         async3(function(){
//             async4(function(){
//             ....
//             });
//         });
//     });
// });

//--57--//Что такое события, отправляемые сервером
// События, отправленные сервером (SSE) — это технология push-уведомлений сервера,
// позволяющая браузеру получать автоматические обновления с сервера через HTTP-соединение,
// не прибегая к опросу. Это односторонний канал связи — события передаются только от сервера к клиенту.
// Это использовалось в обновлениях Facebook/Twitter, обновлениях цен на акции, новостных лентах и т.д.

//--58--//Как вы получаете уведомления о событиях, отправленные сервером
// Объект EventSource используется для получения уведомлений о событиях
// if (typeof EventSource !== "undefined") {
//     var source = new EventSource("sse_generator.js");
//     source.onmessage = function (event) {
//         document.getElementById("output").innerHTML += event.data + "<br>";
//     };
// }

//--59--//Как проверить поддержку браузером событий, отправленных сервером?
if (typeof EventSource !== "undefined") {
    // Server-sent events supported. Let's have some code here!
} else {
    // No server-sent events supported
}

//--60--//Какие события доступны для событий, отправленных сервером?
// Event	Description
// onopen Используется при открытии соединения с сервером
// onmessage Это событие используется при получении сообщения.
// onerror Это происходит, когда возникает ошибка

//--61--//Каковы основные правила promise
// Промис (Promise) в JavaScript — это объект, представляющий конечное завершение или сбой асинхронной операции.
// 1.Ожидающеий промис может перейти в состояние «fulfilled » или «rejected ».
// 2.Выполненное или отклоненное обещание является сохраненным и не должно переходить в какое-либо другое состояние.
// 3.После того как обещание выполнено, его значение не должно меняться.
//Состояния Promise: Promise может находиться в одном из трёх состояний:
// pending (ожидание): начальное состояние, ни выполнено, ни отклонено.
// fulfilled (выполнено успешно): означает, что операция была успешно завершена.
// rejected (отклонено): означает, что операция завершилась с ошибкой.
// Переходы между состояниями Promise не может перейти из состояния выполнено или отклонено обратно в состояние ожидания.

//--62--//Что такое коллбэк в коллбэке
// Вы можете вложить один колбэк коллбэк,
// чтобы выполнять действия последовательно одно за другим.
// doSomething(function(result) {
//     doSomethingElse(result, function(newResult) {
//         doAnotherThing(newResult, function(finalResult) {
//             console.log('Got the final result: ' + finalResult);
//         }, failureCallback);
//     }, failureCallback);
// }, failureCallback);
// Проблема с коллбэками в коллбэках (или "ад коллбэков", как его иногда называют)
// возникает, когда у вас есть много вложенных коллбэков./

// //--63--//Что такое цепочка промисов
// // Процесс выполнения асинхронных задач одна за другой.
// new Promise(function (res,rej) {
//     setTimeout(()=>res(1),1000) //Первоначальный промис выполняется за 1 секунду
// }).
// then(function (result) {
//     console.log(887,result)
//     return result * 2
// })
//     .then(function (result) {
//         console.log(891,result)
//         return result * 3
//     })
//     .then(function (result){
//         console.log(895,result)
//     })
// //-------------------------------------Аналог примера выше, но коллбэк хелл
// function doSmt(callback){
//     setTimeout(()=>callback(2),500)
// }
// doSmt(function (result) {
//     console.log(902,result)
//     let newRes = result *2
//
//     doSmt(function (result) {
//         console.log(newRes)
//         let newRess = newRes * 3
//
//         doSmt(function (result){
//             console.log(newRess)
//             let newResss = newRess * 4
//
//             doSmt(function (result){
//                 console.log(newResss)
//             })
//         })
//
//     })
// })
//
// //--64--//Что такое promise.all
// // Это метод в JavaScript, который принимает массив промисов
// // (или итерируемый объект) и возвращает новый промис,
// // который выполнится, когда все промисы в переданном массиве будут выполнены.
// // Если хотя бы один из промисов отклонится, то возвращаемый промис тоже будет отклонён.
// let promise1 = Promise.resolve(3);
// let promise2 = 42;
// let promise33 = new Promise((resolve, reject) => {
//     setTimeout(resolve, 100, 'foo');
// });
// //(вывод результата) сохраняется в соответствии с порядком ввода.
// Promise.all([promise1,promise33,promise2]).then((values)=>{
//     console.log(933,values)
// })
//
// //--65--//Что такое promise.race
// // Метод Promise.race() вернет экземпляр Promise, который был первым разрешен или отклонен.
// let pr1 = new Promise(function (res,rej) {
// setTimeout(res,500,"one")
// });
// let pr2 = new Promise(function (res,rej) {
//     setTimeout(res,100,"two")
// });
// Promise.race([pr1,pr2]).then(function (value){
//     console.log(945,value)
// })

//--66--//Что такое строгий режим в JavaScript
// Строгий режим — это новая функция ECMAScript 5, которая позволяет поместить программу
// или функцию в «строгий» рабочий контекст. Таким образом, он предотвращает выполнение
// определенных действий и генерирует больше исключений.
// если вы хотите сделать свой JavaScript код более надежным и предсказуемым, рекомендуется использовать строгий режим.
// Строгий режим можно включить добавлением строки "use strict"; в начале файла или функции.
// В этом режиме, например, попытка присвоить значение необъявленной переменной вызовет ошибку,
// в то время как в нестрогом режиме JavaScript просто создаст новую глобальную переменную,
// что может привести к неожиданному поведению кода.

// "use strict";
function exampleFunction() {
     undeclaredVariable = "This will throw an error in strict mode";
    return undeclaredVariable
}
console.log(exampleFunction())

//--67--//Зачем нужен строгий режим
// Строгий режим полезен для написания «безопасного» JavaScript, уведомляя «плохой синтаксис» о реальных ошибках.
// Например, он исключает случайное создание глобальной переменной путем выдачи ошибки,
// а также выдает ошибку при присвоении свойству, не доступному для записи,
// свойству, доступному только для получения, несуществующему свойству,
// несуществующей переменной или несуществующему свойству.

//--68--//Как объявить строгий режим
// Строгий режим объявляется добавлением «use strict»; в начало скрипта или функции.
// Если он объявлен в начале скрипта, он имеет глобальную область действия.
// "use strict";
// x = 3.14; // This will cause an error because x is not declared
// console.log(977,x)
// x = 3.14; // This will not cause an error.
// myFunction();
//
// function myFunction() {
//     "use strict";
//     y = 3.14; // This will cause an error
// }
//
// console.log(myFunction())

//--69--//Зачем нужно двойной восклицание
// Нужно для того, чтобы результат привести к булену
console.log(990,!!0)
console.log(990,!!"")
console.log(991,!0)

//--70--//Зачем нужен оператор delete
let person = new Object({firstName:"Oleg", lastName:"Doe", age:28})
console.log(person)
delete person.age
console.log(person)
// Оператор удаления используется для удаления свойства, а также его значения.

//--71--//Что такое оператор typeof
//Для того, чтобы определить тип переменной, мы его используем
console.log(1003,typeof console.log("2"))
console.log(typeof "")
console.log(typeof 2)
console.log(typeof Set)

//--72--//Что такое undefined
//undefined - это специальное значение, которое присваивается переменным,
// которые были объявлены, но еще не были инициализированы
// Указывает, что переменной не присвоено значение или она не инициализирована
let o;
console.log(o)
console.log(typeof o)

//--73--//Что такое null
//Значение null представляет намеренное отсутствие какого-либо значения объекта, это примитив.
let iop = null
console.log(1019,iop)

//--74--//Отличие null vs undefined
// null                                            undefined
// Специально указывает на отсутсвие значения   указвает, что переменная есть, но значение еще не присвоено
                                        // typeof разный
// преобразуется в 0 при выполнении           преобразуется в NaN при выполнении примитивных операции
// примитивных операции
// console.log(null + 0)
// console.log(null +"")
// console.log(null + NaN)
// console.log(undefined + NaN)//NaN
// console.log(undefined + 0)//NaN
// console.log(1032,undefined + "")// "1032 undefined"
// console.log("www" + 1)
// console.log("www" - 1)

//--75--//Что такое eval
//Метод eval()  это глобальная функция, выполняет JavaScript-код, представленный строкой.
console.log(eval("3 + 3"))

//--76?--//Разница между window and document
// Window                                              vs Document
// элемент корневого уровня на любой веб-странице.   Это прямой дочерний элемент окна.
// По умолчанию объект window                        получить к нему доступ возможно window.document или document.
// неявно доступен на странице.                      некоторые из методов, которые представляет:
//Имеет методы: alert, confirm и свойства,           getElementById, getElementsByTagName, createElement и т. д.
// document, location

//--77?--//Как получчить доступ к истории JS
// Объект window.history содержит историю браузера.
// Можно загрузить предыдущий и следующий URL-адреса в историю, используя методы back() и next().
// function goBack() {
//     window.history.back();
// }
// function goForward() {
//     window.history.forward();
// }

//--78?--//
//--79?--//Что такоe isNaN
// Это функция, которая используется для опеределения, не является ли числом значение
console.log(isNaN(100))//false
console.log(isNaN("wwww"))//true
//Может быть полезна, если нам нужно точно знать, дейтсвительно ли значение является числом

//--80--//В чем разница между необъявленными и неопределенными переменными
// необъявленные (undeclared)                        vs       неопределены(undefined)
// Не объявлены и вообще не существуют в программе            Объявляены, но еще не имеют никакого значения
//                                                            let a; console.log(a)//undefined
//Если попробовапть прочитать значение, то возникнет          -//-будет возвращено неопределенное значение.
//ошибка времени исполнения(runtime error)(ReferenceError)

//--81--//Что такое глобальная переменная
//Это переменная, которая доступна в любой части кода, которая не имеет области видимости
msg = "Hello"; // var is missing, it becomes global variable
console.log(msg)

//--82--//Какие проблемы могут быть с глобальными переменными
// 1.Могут возникнуть конфликты имен в локальной и глобальной области видимости.
// 2.  Могут возникнуть сложности в тестировании кода
//3.Можем не заметив изменить глобальную пермеенную, что моет привести к ошибкам
var testVar = "I'm global var"
function test(){
    var testVar = "I'm local var"
    console.log(testVar)
}
test()
console.log(testVar)

//--83--//Что такое свойство NaN
//Это глобалььное свойство, которое означает не число, т.е. указвыает, что значение не является допустимым числом
console.log(Number("www"))
console.log(Math.sqrt(-1))
console.log(1-"ww")

//--84--//Зачем нужна функция isFinite
//Нужна для того,чтобы опеделить, являяется ли число конечным допустимым числом.
console.log(isFinite(Infinity))
console.log(isFinite(1))
console.log(isFinite(2))

//--85?--//Что такое поток событий(event flow)
// Поток событий — это порядок, в котором события принимаются на веб-странице.
// Когда происходит щелчок на элемент, вложенный в различные другие элементы,
// прежде чем щелчок действительно достигнет места назначения или целевого элемента,
// он должен сначала вызвать событие щелчка для каждого из своих родительских элементов,
// начиная сверху с объекта глобального окна.
//Существует два события потока:
// Сверху вниз(Event Capturing)
// Снизу вверх(Event Bubbling)

//--86--//Что такое event bubbling
// Это дефолтное поведение в JavaScript, когда событие сначала обрабатывается
// на самом вложенном элементе, и затем "всплывает" к его родительским элементам.
// Это тип распространения событий, при котором событие сначала срабатывает
// на самом внутреннем целевом элементе, а затем последовательно срабатывает на предках (родителях)
// целевого элемента в той же иерархии вложенности, пока не достигнет самого внешнего
// элемента DOM (т. е. глобального окна). объект
// Это стандартное поведение событий на элементах, если вы не остановите его.
// Всплытие событий начинается с самого глубокого (или наиболее вложенного) элемента
// и затем всплывает к более высоким уровням дерева DOM.
// <div onClick = "alert('div')">
//     <button onClick = "alert('button')"> ClickMe < /button>
// </div>
// сначала сработает обработчик события onclick кнопки,
// а затем событие "всплывет" к родительскому div и сработает его обработчик.

//--87--//Что такое event capturing(перехват событий)
// полная противоположность баблингу, тип распространения событий,
// при котором событие сначала фиксируется самым внешним элементом,
// а затем последовательно срабатывает на потомках (дочерних элементах)
// целевого элемента в той же иерархии вложенности, пока не достигнет
// самого внутреннего целевого элемента DOM.

//--88--//Как отправить форму с помощью JavaScript
// отправить форму, используя document.forms[0].submit().
// Вся информация ввода формы отправляется с использованием обработчика событий onsubmit.
function submit() {
    document.forms[0].submit();
}

//--89?--//Как найти сведения об операционной системе
// Объект window.navigator содержит информацию о деталях ОС браузера посетителя.
// console.log(navigator.platform);

//--90?--//В чем разница между document load и DOMContentLoaded events
// Событие DOMContentLoaded вызывается, когда исходный HTML-документ полностью загружен и проанализирован,
// не дожидаясь завершения загрузки ресурсов (таблиц стилей, изображений и подкадров).
// В то время как событие загрузки вызывается при загрузке всей страницы,
// включая все зависимые ресурсы (таблицы стилей, изображения).

//--91?--//В чем разница между собственными, хостовыми и пользовательскими объектами
// Собственные объекты — это объекты, являющиеся частью языка JavaScript,
// определенного спецификацией ECMAScript.
// Например, основные объекты String, Math, RegExp, Object, Function
// Хост-объекты — это объекты, предоставляемые браузером или средой выполнения (Node).
// Например, окно, XmlHttpRequest, узлы DOM и т. д. считаются хост-объектами.
// Пользовательские объекты — это объекты, определенные в коде JavaScript.
// Например, объекты «Пользователь», созданные для информации профиля.

//--92--//Какие инструменты или методы используются для отладки кода JavaScript?
// 1.Chrome Devtools
// 2.debugger statement
// 3.console.log

//--93--//Каковы плюсы и минусы промисов перед обратными вызовами(callback)
//+
// Мы избегаем колбэк хэлла
//Легко писать последовательный асинхронный код с помощью .then()
//Легко писать параллельный асинхронный код с помощью Promise.all()
//Решает некоторые распространенные проблемы обратных вызовов (вызов обратного вызова слишком поздно,
// слишком рано, много раз и проглатывает ошибки/исключения).
//-
//необходимо нагружать наш кож полифиллос, если ES6 не поддерживается.

//--94?--//В чем разница между атрибутом и свойством
// Атрибуты определяются в разметке HTML,
// тогда как свойства определяются в DOM.
// атрибуты инициализируют свойства DOM, и в то время как значения атрибутов остаются неизменными,
// значения свойств могут меняться в процессе выполнения скрипта.
// Например, приведенный ниже элемент HTML имеет 2 атрибута типа и значения:
// <input type="text" value="Name:">

//--95--//Что такое политика одного и того же происхождения(same-origin policy)
// это политика, которая запрещает JavaScript выполнять запросы через границы домена.
// Источник определяется как комбинация схемы URI, имени хоста и номера порта.
// Если включить эту политику, она не позволит вредоносному сценарию на одной странице получить доступ
// к конфиденциальным данным на другой веб-странице с помощью объектной модели документа (DOM).

//--96--//Для чего void 0
// Void(0) используется для предотвращения обновления страницы.
// используется для получения примитивного значения undefined
// В больших кодовых базах это может быть важно, так как минификаторы
// кода часто заменяют undefined на void 0, чтобы уменьшить количество байтов, передаваемых в браузер.
console.log(void 0)

//--97--//Каким языком является JS компилируемый(compiled) или интерпретируемый(interpreted ) язык
// JavaScript — это интерпретируемый язык, а не компилируемый язык.
// Интерпретатор в браузере читает код JavaScript, интерпретирует каждую строку и запускает его.
// В настоящее время современные браузеры используют технологию,
// известную как компиляция Just-In-Time (JIT), которая компилирует JavaScript
// в исполняемый байт-код непосредственно перед его запуском.

//--98--//Чувствителен ли  к регистру JS?
// Да, JavaScript — язык, чувствительный к регистру.
// Ключевые слова языка, переменные, имена функций и объектов, а также любые
// другие идентификаторы всегда должны вводиться с использованием заглавных букв.

//--99--//Есть ли какая-либо связь между Java и JavaScript?
// Нет, это совершенно два разных языка программирования и не имеют друг с другом ничего общего.
// Но оба они являются языками объектно-ориентированного программирования и,
// как и многие другие языки, имеют схожий синтаксис для основных функций
// (if, else, for, switch, break).

//--100--//Что такое события
// События — это сигналы, которые происходят с элементами HTML.
// это сигналы от браузера о том, что что-то произошло.
// Когда JavaScript используется на страницах HTML, JavaScript может реагировать на эти события.
// Вот некоторые примеры событий HTML:
// function greeting() {
//     alert('Hello! Good morning');
// }
//
// <button type="button" onClick="greeting()">Click me</button>

//--101--//Кто создал JavaScript
// JavaScript был создан Бренданом Эйхом в 1995 году, когда он работал в Netscape Communications.
// Первоначально он был разработан под названием Mocha, но позже язык получил официальное название
// LiveScript, когда он впервые появился в бета-версиях Netscape.

//--102--//Зачем нужен preventDefault
//preventDefault - это метод в JavaScript, который используется,
// когда мы хотим предотвратить действие браузера по умолчанию, связанное с определенным событием.
// Например, при нажатии на ссылку браузер обычно перенаправляет пользователя на другую страницу.
// Если мы не хотим, чтобы это произошло, мы можем использовать preventDefault в обработчике события клика
// document.querySelector('a').addEventListener('click', function(event) {
//     event.preventDefault();
//     // Ваш код
// });
//preventDefault полезен, когда мы хотим переопределить стандартное поведение браузера.

//--103--//Для чего нужен метод stopPropagation
//Если нам нужно остановить всплытие мы используем этот метод
// Всплытие события - это процесс, при котором событие запускается сначала на самом вложенном элементе
// и затем всплывает вверх по DOM-дереву, запускаясь на каждом родительском элементе по пути.
// Это стандартное поведение в JavaScript для большинства событий.
//про всплытие еще пример
// document.querySelector('div').addEventListener('click', function() {
//     console.log('Кликнули по div!');
// });
//
// document.querySelector('button').addEventListener('click', function() {
// event.stopPropagation();
//     console.log('Кликнули по кнопке!');
// });

//--104--//Что делает return false в обратботчике событий
//1.Останавливает действие/поведение браузера по умолчанию(Это аналогично вызову event.preventDefault().)
// document.querySelector('a').addEventListener('click', function(event) {
//     event.preventDefault();
//     console.log('Ссылка была кликнута, но переход не произошел.');
// });
//2.Предотвращает распространение события в DOM(Это аналогично вызову event.stopPropagation().)
// document.querySelector('a').addEventListener('click', function(event) {
//     // Ваш код
//     return false;
// });
//3.Останавливает выполнение коллбэка и немедленно возвращает результат при вызове

//--105--//Что такое BOM
// Объектная модель браузера (BOM) позволяет JavaScript «общаться» с браузером.
// (это интерфейс для взаимодействия с браузером. )
// Основные объекты BOM включают следующие:
//     window: Это глобальный объект и самый верхний уровень в иерархии BOM.
//     Все остальные объекты, такие как document, history и location, являются свойствами объекта window.
//     location: Этот объект предоставляет информацию о текущем URL и
//     позволяет скрипту перенаправлять браузер на новый URL.
//     history: Предоставляет доступ к истории браузера.
//     Например, с его помощью вы можете перенаправить пользователя назад или вперед по истории браузера.
//     navigator: Содержит информацию о браузере пользователя.
//     screen: Предоставляет информацию о физическом экране пользователя, такую как его разрешение.
//     document: Является точкой входа в DOM вашего сайта.
//Используя BOM, вы можете делать такие вещи, как управление размером окна браузера,
// создание новых окон, определение высоты и ширины экрана пользователя,
// перенаправление пользователя на другой URL и многое другое.
//Объектная модель браузера не стандартизирована и может меняться в зависимости от браузера.

//--106--//Что такое setTimeout и зачем нужен
//setTimeout() это функция в JavaScript, которая используется для выполнения кода
// или функции после определенного времени задержки.
setTimeout(()=>{
    console.log("2 sec is done")
},2000)

//--107--//Что такое setInterval и зачем нужен
//setInterval - это функция в JavaScript, которая используется для периодического
// выполнения указанного кода с заданным интервалом времени.
let interval = setInterval( ()=> {
    console.log("Good morning");
}, 2000);
clearInterval(interval)
//Чтобы остановить выполнение функции, вызванной с помощью setInterval,
// можно использовать функцию clearInterval(), передав ей идентификатор интервала,
// который возвращает setInterval.

//--108--//Почему JS является однопоточным
//Это связано с тем, что JavaScript изначально был разработан для работы в браузерах,
// и основная его задача - взаимодействие с пользователем, манипуляции с DOM и обработка событий.
// В таком контексте многопоточность может привести к проблемам, таким как состояние гонки (race conditions).
//**Состояние гонки (race condition) - это ситуация в многопоточной среде,
// когда два или более потока пытаются обратиться к общим данным или ресурсу одновременно.
// Это может привести к непредсказуемым или ошибочным результатам,
// потому что порядок выполнения потоков может изменяться каждый раз при выполнении программы.

//--109--//Что такое делегирование события(event delegation)
// Делегирование событий — это метод прослушивания событий, при котором мы делегируем
// родительский элемент в качестве прослушивателя всех событий, происходящих внутри него.
// Например, если нужно обнаружить изменения полей внутри определенной формы, мы можем использовать
// технику делегирования событий:
// var form = document.querySelector("#registration-form");
//
// // Listen for changes to fields inside the form
// form.addEventListener(
//     "input",
//     function (event) {
//         // Log the field that was changed
//         console.log(event.target);
//     },
//     false
// );

//--110--//Что такое ECMAScript
// ECMAScript — это язык сценариев, лежащий в основе JavaScript.
// ECMAScript стандартизирован международной организацией по стандартизации ECMA
// в спецификациях ECMA-262 и ECMA-402. Первая редакция ECMAScript была выпущена в 1997 году.

//--111--//Что такое JSON
// JSON (нотация объектов JavaScript) (JavaScript Object Notation) — это облегченный формат,
// используемый для обмена данными. Он основан на подмножестве языка JavaScript,
// который используется для построения объектов в JavaScript.

//--112--//Каковы правила синтаксиса JSON?
//1.Данные находятся в парах имя/значение.(ключ-значение)
//2. Данные разделяются запятыми
//3.Фигурные скобки удерживают объекты
//4.Квадратные скобки содержат массивы

//--113--//Зачем нужен JSON stringify
// При отправке данных на веб-сервер данные должны быть в строковом формате.
// Чтобы это сделать нужно преобразовать объект JSON в строку с помощью метода stringify().
let userJSON = { name: "John", age: 31 };
let userString = JSON.stringify(userJSON);
console.log(userString); //"{"name":"John","age":31}"

//--114--//Зачем нужен  parse JSON
// При получении данных с веб-сервера данные всегда имеют строковый формат.
// Но для преобразования строкового значения в объект javascript, используется метод parse().
let userString2 = {"name":"John","age":31}
let userJSON2 = JSON.stringify(userString2);
console.log(userString2); //"{"name":"John","age":31}"

//--115--//Зачем нужен  JSON((JavaScript Object Notation))
// это формат данных, который используется для структурирования и обмена данными между браузером и сервером
// При обмене данными между браузером и сервером данные могут быть только текстовыми.
// Поскольку JSON — это только текст, его можно легко отправлять на сервер и принимать.

//--116--//Что такое PWA
// Прогрессивные веб-приложения (PWA) — это тип мобильных приложений,
// предоставляемых через Интернет и созданных с использованием распространенных веб-технологий,
// включая HTML, CSS и JavaScript. Эти PWA развертываются на серверах,
// доступны через URL-адреса и индексируются поисковыми системами.

//--117--//Какова цель методаclearTimeout?
// Функция clearTimeout() используется в javascript для очистки таймаута,
// установленного до этого функцией setTimeout(). т. е. возвращаемое значение функции setTimeout()
// сохраняется в переменной и передается в функциюclearTimeout() для очистки таймера.
// let funcTim
// function saySmth(){
//     console.log("KKKKKKKKKKKK");
// }
// function start(){
//     funcTim = setTimeout(saySmth,2000)
// }
// function stop() {
//     clearTimeout(funcTim)
// }

//--118--//Какова цель метода  clearInterval?
// Аналогия с методом clearTimeout.
// Функция ClearInterval() используется в JavaScript для очистки интервала,
// установленного функцией setInterval(). т. е. возвращаемое значение, возвращаемое функцией setInterval(),
// сохраняется в переменной и передается в функциюclearInterval() для очистки интервала.
// let msgg;
// function greeting() {
//     console.log('Good morning');
// }
// function start() {
//     msgg = setInterval(greeting, 3000);
//     stop()
// }
// function stop() {
//     clearInterval(msgg);
// }
// start()
// setTimeout(stop,7000)

//--119--//Как перенаправить на  новую страницу в JavaScript
// В ванильном JavaScript вы можете перенаправить на новую страницу,
// используя свойство location объекта окна. Синтаксис будет следующим:
function redirect() {
    window.location.href = "newPage.html";
}

//--120--//Как проверить, содержит ли строка подстроку
//Существует 3 способа проверки
// | Using includes: ES6 предоставил метод String.prototype.includes для проверки того,
// что строка содержит подстроку.
let mainString = "hello",
    subString = "hell";
console.log(1419,mainString.includes(subString))
// || Использование indexOf: в среде ES5 или более ранней версии вы можете использовать
// String.prototype.indexOf, который возвращает индекс подстроки.
// Если значение индекса не равно -1, это означает, что подстрока существует в основной строке.
let mainString2 = "hello",
    subString2 = "hell";
console.log(1425,mainString2.indexOf(subString2) !== -1)
// ||| Использование RegEx: расширенное решение использует метод проверки регулярных выражений (RegExp.test),
// который позволяет проводить тестирование регулярных выражений.
let mainString3 = "hello",
    regex = /hell/;
console.log(1430, regex.test(mainString))
///Реальные примеры
let email = "user@example.com";
if (email.includes("@")) {
    console.log("Это адрес электронной почты.");
} else {
    console.log("Это не адрес электронной почты.");
}
function yesOrNo(mail){
    if(mail.includes("@")){
     return ("Good boy")
    } else {
        return ('Bad message')
    }
}

console.log(yesOrNo("Mail@www"))

//--121--//Как проверить электронную почту в JavaScript
//Можно проверить электронную почту в JavaScript, используя регулярные выражения.
// Рекомендуется выполнять проверки на стороне сервера, а не на стороне клиента.
// Потому что JavaScript можно отключить на стороне клиента.
// function validateEmail(email) {
//     var re =
//         /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
//     return re.test(String(email).toLowerCase());
// }

//--122--//Как получить текущий URL с помощью JavaScript
// Можно использовать выражение window.location.href для получения текущего
// URL-адреса, а также использовать то же выражение для обновления URL-адреса.
// Также можете использовать document.URL только для чтения, но у этого решения есть проблемы в FF.
// console.log("location.href", window.location.href); // Returns full URL

//--123--//Какие свойства URL объекта
// Объект URL в JavaScript предоставляет свойства для работы с URL.
// Эти свойства включают:
//href: Полный URL.
//protocol: Протокол URL (например, "http:" или "https:").
//host: Хост и порт URL (например, "www.example.com:8000").
//hostname: Хост URL (например, "www.example.com").
//port: Порт URL (например, "8000").
//pathname: Путь URL (например, "/path/name").
//search: Часть URL, которая следует за символом вопроса, включая символ вопроса (например, "?query=string").
//hash: Часть URL, которая следует за символом решетки, включая символ решетки (например, "#fragment").
//Все эти свойства доступны для чтения и записи, за исключением href, который доступен только для чтения.

//--124--//Как получить значения строки запроса в JavaScript
//Можно использовать URLSearchParams для получения значений строки запроса в JavaScript.
//Пример получения значения кода клиента из строки запроса URL:
// const urlParams = new URLSearchParams(window.location.search);
// const clientCode = urlParams.get("clientCode");

//--125--//Как проверить, существует ли ключ в объекте
//1.Использование оператора in: вы можете использовать оператор in
// независимо от того, существует ли ключ в объекте или нет.
// "key" in obj;
//!("key" in obj);
//2.Использование метода hasOwnProperty: вы можете использовать hasOwnProperty
// для проверки свойств экземпляра объекта (а не унаследованных свойств).
// obj.hasOwnProperty("key"); // true
//3.Использование неопределенного сравнения: если вы получаете доступ к несуществующему свойству объекта,
// результат не определен. Давайте сравним свойства с неопределенными, чтобы определить существование свойства.
// const user = {
//     name: "John",
// };
//
// console.log(user.name !== undefined); // true
// console.log(user.nickName !== undefined); // false

//--126--//Как перебрать объект
// Вы можете использовать цикл for-in для перебора объекта javascript.
// Вы также можете убедиться, что полученный вами ключ является реальным свойством объекта,
// а не получен из прототипа, используя метод hasOwnProperty.
let objectEx = {
    k1: "value1",
    k2: "value2",
    k3: "value3",
};
for (const key in objectEx) {
    if(objectEx.hasOwnProperty(key)){
        console.log(1511,key + "-->" + objectEx[key])
    }
}

//--127--//Как проверить пустой объект
//Существуют разные решения на основе версий ECMAScript.
//|.Использование записей объекта (ECMA 7+): вы можете использовать длину записей объекта вместе с типом конструктора.
// Object.entries(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
//||.Использование ключей объекта (ECMA 5+): вы можете использовать длину ключей объекта вместе с типом конструктора.
// Object.keys(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
//|||.Использование for-in с hasOwnProperty (до ECMA 5): вы можете использовать цикл for-in вместе с hasOwnProperty.
// function isEmpty(obj) {
//     for (var prop in obj) {
//         if (obj.hasOwnProperty(prop)) {
//             return false;
//         }
//     }
//     return JSON.stringify(obj) === JSON.stringify({});
// }
// let objExp2 = {}
// console.log(1531,Object.entries(objExp2).length === 0 && objExp2.constructor === Object)

//--128--//Что такое объект аргументов
// Объект аргументов — это объект типа Array, доступный внутри функций,
// который содержит значения аргументов, переданных этой функции. Например,
// function sum(){
//     let total = 0;
//     for(let qq=0, len = arguments.length; qq<len; ++qq){
//         total += arguments[qq]
//     }
//     return total
// }
//
// console.log(sum(1,2,3))

//--129--//Как сделать первую букву строки заглавной?
// можете создать функцию, которая использует цепочку строковых методов,
// таких как charAt, toUpperCase и методы среза, для создания строки с первой буквой в верхнем регистре.
function upFirstLetter(str){
    return str.charAt(0).toUpperCase() + str.slice(1)
}
console.log(upFirstLetter("popka"))

//--130--//Каковы плюсы и минусы циклов for?
// Плюсы
//|.Работает в любой среде
//||.Вы можете использовать операторы управления прерывания и продолжения.
//Минусы
//Ошибки off-by-one: одной из самых распространенных ошибок при использовании циклов for является ошибки off-by-one,
//когда цикл выполняется на одну итерацию больше или меньше, чем нужно.
//Неудобство использования с некоторыми структурами данных: хотя циклы for могут быть
//использованы для обхода различных структур данных, они могут быть не такими удобными или эффективными,
//как специальные методы обхода, такие как Array.prototype.forEach или Array.prototype.map.
//Сложность управления состоянием: в некоторых случаях, особенно при работе с асинхронными операциями,
//управление состоянием внутри цикла for может быть сложным.

//--131--//Как отобразить текущую дату в JavaScript
// использовать new Date() для создания нового объекта Date, содержащего текущую дату и время.
// var today = new Date();
// var dd = String(today.getDate()).padStart(2, "0");
// var mm = String(today.getMonth() + 1).padStart(2, "0"); //January is 0!
// var yyyy = today.getFullYear();
//
// today = mm + "/" + dd + "/" + yyyy;
// console.log(today)

//--132--//Как сравнить два объекта даты
// нужно использовать метод date.getTime() для сравнения значений даты вместо операторов сравнения (операторов ==, !=, === и !==).
let d1 = new Date();
let d2 = new Date(d1);
console.log(d1)
console.log(d2)
// console.log(d1.getTime() === d2.getTime()); //True
// console.log(d1 === d2); // False

//--133--//Как проверить, начинается ли строка с другой строки
// Вы можете использовать метод String.prototype.startsWith() ECMAScript 6,
// чтобы проверить, начинается ли строка с другой строки или нет.
// Но он пока поддерживается не во всех браузерах. Давайте посмотрим пример, чтобы увидеть это использование,
// "Good morning".startsWith("Good"); // true
// "Good morning".startsWith("morning"); // false

//--134--//Как обрезать строку в JavaScript
// В JavaScript предусмотрен метод, позволяющий обрезать любые пробелы, присутствующие в начале или конце строки.
console.log("  Hello World   ".trim()) //Hello World)
// Если ваш браузер (<IE9) не поддерживает этот метод, вы можете использовать приведенный ниже полифилл.
// if (!String.prototype.trim) {
//     (function () {
//         // Make sure we trim BOM and NBSP
//         var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
//         String.prototype.trim = function () {
//             return this.replace(rtrim, "");
//         };
//     })();
// }

//--135--//Как добавить пару ключ-значение в JavaScript
// Существует два возможных решения для добавления новых свойств к объекту.
// Давайте возьмем простой объект, чтобы объяснить эти решения.
let object135 = {
    key1: 22,
    key2: 22,
};
//|Использование точечной записи: это решение полезно, если вы знаете имя свойства.
object135.key3 = "value3";
console.log(object135)
//||Использование квадратных скобок. Это решение полезно, когда имя свойства определяется динамически.
object135["key4"] = "value4";
console.log(object135)

//--136--//Что !-- представляет собой  как пециальный оператор
// |Логическое нет (!)
// |Декремент префикса  (--)
//Сначала значение уменьшается на единицу,
// а затем проверяется, равно ли оно нулю или нет, для определения истинного/ложного значения.

//--137--//Как присвоить переменным значения по умолчанию
//  использовать логический оператор или || в выражении присваивания, чтобы указать значение по умолчанию.
// let a = b || c;
//переменная «a» получит значение «c», только если «b» имеет ложное значение (если оно равно нулю, ложно, неопределенно, 0, пустая строка или NaN),
// в противном случае «a» получит значение значение «б».

//--138--//Как определить многострочные строки
// используя символ '\n', за которым следует признак конца строки('').
let str138 =
    "This is a \n\ very lengthy \n\ sentence!";
console.log(str138);
// Но если после символа '\n' стоит пробел, возникнут несоответствия в отступах.

//--139--//Что такое модель оболочки приложения
// Архитектура оболочки приложения (или оболочки приложения) — это один из способов создания
// прогрессивного веб-приложения, которое надежно и мгновенно
// загружается на экранах ваших пользователей, подобно тому, что вы видите в собственных приложениях.
// Это полезно для быстрого вывода исходного HTML-кода на экран без подключения к сети.

//--140--//Можем ли мы определить свойства для функций
// Да, мы можем определять свойства функций, поскольку функции также являются объектами.
fn140 = function (x) {
    //Function code goes here
};

fn140.name = "John";
console.log(1653,fn140.name)
fn140.profile = function (y) {
    //Profile code goes here
};
console.log(1657,fn140.profile("OPP"))

//--141--//Как найти количество параметров, ожидаемых функцией?
// использовать синтаксис function.length, чтобы найти количество параметров, ожидаемых функцией.
function sum(sum1,sum2,sum3,sum4){
    return sum1 + sum2 + sum3 + sum4
}
console.log(1665,sum.length)

//--142--//Что такое полифил
// Полифил — это фрагмент JS-кода, используемый для обеспечения современных функций в старых браузерах,
// которые не поддерживают его изначально.
// Доступны две основные библиотеки полифилов:
//|.Core.js: это модульная библиотека JavaScript, используемая для передовых функций ECMAScript.
//||. Polyfill.io: предоставляет полифиллы, необходимые для нужд браузера.

//--143--//Что такое операторы break  и continue
// Оператор Break используется для «выхода» из цикла. т. е. он разрывает цикл и продолжает выполнение кода после цикла.
for(let i=0;i<10;i++){
    if(i === 5){
        break;
    }
    console.log("Number: " + i )
}
// Оператор continue используется для «перепрыгивания» одной итерации цикла. т. е.
// он прерывает одну итерацию (в цикле), если возникает указанное условие, и продолжает следующую итерацию в цикле.
for (i = 0; i < 10; i++) {
    if (i === 5) {
        continue;
    }
    console.log(1687,"Number: " + i )
}

//--144--//Что такое js-метки
//Оператор label позволяет нам называть циклы и блоки в JavaScript.
// Затем мы можем использовать эти метки, чтобы позже вернуться к коду.
let i144, j144;

loop1: for (i144 = 0; i144 < 3; i144++) {
    loop2: for (j144 = 0; j144 < 3; j144++) {
        if (i144 === j144) {
            continue loop1;
        }
        console.log(1700, "i = " + i144 + ", j = " + j144);
    }
}

//--145--//Каковы преимущества размещения объявлений вверху( declarations at the top)?
// Рекомендуется хранить все объявления в начале каждого скрипта или функции.
// Преимущества этого заключаются в том,
//|.Дает более чистый код(Улучшение читаемости)
//||.Он предоставляет единое место для поиска локальных переменных.
//|||.Легко избежать нежелательных глобальных переменных
//||||. Это снижает вероятность нежелательных повторных деклараций.